import functools
import json
import random
import time
import websockets
from keep_reserve import *
import websocket
import requests
from keep_session import *
from lib_configs import *
import schedule
import my_email
from threading import Thread
import ssl
from my_socket import *
import asyncio

usr_list = []
# basic configs
seat_key, lib_id = the_seat_chosen[0], the_lib_chosen[0]
# save
params_confirm_seat = {
    "operationName": "save",
    "query": "mutation save($key: String!, $libid: Int!, $captchaCode: String, $captcha: String) {\n userAuth {\n prereserve {\n save(key: $key, libId: $libid, captcha: $captcha, captchaCode: $captchaCode)\n }\n }\n}",
    "variables": {
        # ËøôÈáåÁöÑ"key"ÔºöÂ¶ÇÊûú‰∏çÊòØÂ∏∏Áî®Â∫ß‰ΩçÔºåÈúÄË¶ÅÂú®ÊúÄÂêéÈù¢Âä†‰∏Ä‰∏™ '.'
        "key": seat_key + '.',
        "libid": lib_id,
        "captchaCode": "",
        "captcha": ""
    }
}
# libLayout
data_lib_chosen = {
    "operationName": "libLayout",
    "query": "query libLayout($libId: Int!) {\n userAuth {\n prereserve {\n libLayout(libId: $libId) {\n max_x\n max_y\n seats_booking\n seats_total\n seats_used\n seats {\n key\n name\n seat_status\n status\n type\n x\n y\n }\n }\n }\n }\n}",
    "variables": {
        "libId": lib_id
    }
}
# prereserve
params_confirm_seat_info = {"operationName": "prereserve",
                            "query": "query prereserve {\n userAuth {\n prereserve {\n prereserve {\n day\n lib_id\n "
                                     "seat_key\n seat_name\n is_used\n user_mobile\n id\n lib_name\n }\n }\n }\n}"}

url = 'https://wechat.v2.traceint.com/index.php/graphql/'

pre_header = {
    'Host': 'wechat.v2.traceint.com',
    'Connection': 'keep-alive',
    'Content-Length': '309',
    'App-Version': '2.0.14',
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36 NetType/WIFI MicroMessenger/7.0.20.1781(0x6700143B) WindowsWechat(0x63090719) XWEB/8391 Flue',
    'Content-Type': 'application/json',
    'Accept': '*/*',
    'Origin': 'https://web.traceint.com',
    'Sec-Fetch-Site': 'same-origin',
    'Sec-Fetch-Mode': 'cors',
    'Sec-Fetch-Dest': 'empty',
    'Referer': 'https://web.traceint.com/',
    'Accept-Encoding': 'gzip, deflate, br',
    'Accept-Language': 'zh-CN,zh',
    # 'Cookie': cookieStr
}


def catch_exceptions(cancel_on_failure=False):
    def catch_exceptions_decorator(job_func):
        @functools.wraps(job_func)
        def wrapper(*args, **kwargs):
            try:
                return job_func(*args, **kwargs)
            except:
                import traceback
                print(traceback.format_exc())
                my_email.goLib_email_info('error')
                if cancel_on_failure:
                    return schedule.CancelJob

        return wrapper

    return catch_exceptions_decorator


def initialization():
    """
    ËÆÄÂèñÂêÑÂÄãÁî®Êà∂ÁöÑcookieÔºåÁõ¥Êé•‰øùÂ≠òÂà∞ÂÜÖÂ≠ò
    :return:
    """
    global usr_list
    with open('init_conf.json', 'r', encoding='utf-8') as fp:
        usr_list = json.loads(fp.read())['cookies']
    for usr in usr_list:
        usr['cookie'] = usr['cookie'].strip('\r\n')


def queue_pass(ws):
    # ËøûÊé•socketËøõË°åÊéíÈòüÁöÑÂá†ÁßçÊñπÊ≥ï
    # Á¨¨‰∏ÄÁßçÊñπÊ≥ï
    # ws = websocket.WebSocket()
    # ws.connect('wss://wechat.v2.traceint.com/ws?ns=prereserve/queue', header=queue_header)  # ËøôÈáåÁöÑXXXXÂíåHostÂÜÖÂÆπÊòØ‰∏ÄËá¥ÁöÑ

    # Á¨¨‰∫åÁßçÊñπÊ≥ï
    # ws = websocket.create_connection('wss://wechat.v2.traceint.com/ws?ns=prereserve/queue',
    #                                  header=queue_header,
    #                                  sslopt={"cert_reqs": ssl.CERT_NONE})
    # if ws.connected:
    #     print('test pass queue connect')
    #     while True:
    #         ws.send('{"ns":"prereserve/queue","msg":""}')
    #         a = ws.recv()
    #         print(a)
    #         if a.find('u6392') != -1:  # ÊéíÈòüÊàêÂäüËøîÂõûÁöÑÁ¨¨‰∏Ä‰∏™Â≠óÁ¨¶
    #             break
    #         if a.find('u6210') != -1:  # Â∑≤ÁªèÊä¢Â∫ßÊàêÂäüÁöÑËøîÂõû
    #             print("rsp msg:{}".format(json.loads(str(a))["msg"]))
    #             time.sleep(5)
    #             break
    #         print("ÊéíÈòü‰∏≠Ôºårsp:{}".format(a))
    #     # ÂÖ≥Èó≠ËøûÊé•
    #     ws.close()
    # time.sleep(0.01)
    # print("ÊéíÈòüÁªìÊùü„ÄÇ„ÄÇ„ÄÇ")
    # print("================================")

    """Á¨¨‰∏âÁßçÊñπÊ≥ï"""
    # ws = CG_Client(
    #     url="wss://wechat.v2.traceint.com/ws?ns=prereserve/queue",
    #     headers=queue_header
    # )
    # Âú®Êä¢Â∫ßÂºÄÂßã‰πãÂâçÂ∞±Â∑≤ÁªèÂª∫Á´ãÂ•Ω‰∫ÜËøô‰∏™socketÔºåËäÇÁúÅÊó∂Èó¥
    ws.connect()
    ws.run_forever()


async def queue_pass_websockets(open_time):
    """
    Á∂ìÈÅéÂØ¶È©óÔºåÁü•ÈÅì‰∫ÜÔºåÂç≥‰ΩøÊ≤íÂà∞ÊòéÊó•È†êÁ¥ÑÈñãÂßãÁöÑÊôÇÈñìÔºå‰ªçÁÑ∂ÂèØ‰ª•ÈÄ£Êé•ÊúçÂãôÂô®ÔºåÊâÄ‰ª•ÂèØ‰ª•ÁúÅ‰∏ã‰æÜÈÄ£Êé•ÊúçÂãôÂô®ÁöÑÊôÇÈñì
    Áî±Ê≠§Âª∫Á´ãÁ¨¨ÂõõÁ®ÆÊñπÊ≥ï
    """
    # ÂàõÂª∫‰∏Ä‰∏™ SSL ‰∏ä‰∏ãÊñáÂπ∂ÊåáÂÆöÂçèËÆÆÁâàÊú¨
    ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
    ssl_context.check_hostname = False
    ssl_context.verify_mode = ssl.CERT_NONE

    async with websockets.connect("wss://wechat.v2.traceint.com/ws?ns=prereserve/queue",
                                  extra_headers=queue_header_for_websockets,
                                  ssl=ssl_context) as websocket:
        # Âú®Êê∂Â∫ßÈñãÂßãÂâç0.5sÂ∞±Â∞çÊúçÂãôÂô®ÈñãÂßãÁãÇËΩüÊø´ÁÇ∏üòù
        start_preserve = open_time - 0.5
        while True:  # Â§ñÂæ™ÁéØÊéßÂà∂Êó∂Èó¥
            if time.time() >= start_preserve:
                while True:  # ÂÜÖÂæ™ÁéØÊéßÂà∂socketÈÄö‰ø°ÔºåÁõ¥Âà∞Êî∂Âà∞ÊéíÈòüÊàêÂäüÁöÑÊ∂àÊÅØ
                    try:
                        await websocket.send('{"ns":"prereserve/queue","msg":""}')
                        ans = await websocket.recv()
                        if ans.find('u6392') != -1 or ans.find('u6210') != -1:  # ÊàêÂäüÊéíÈòüÔºå2ÂàÜÈíüÂÜÖ„ÄÇ„ÄÇ„ÄÇ„ÄÇ
                            # \u6392ÊéíÂ•ΩÈòüËøîÂõûÁöÑÁ¨¨‰∏Ä‰∏™Â≠óÔºå   \u6210Â∑≤ÁªèÊä¢ÂÆåÂ∫ßËøîÂõûÁöÑÁ¨¨‰∏Ä‰∏™Â≠ó
                            print(json.loads(ans)["msg"])
                            break  # Ë∑≥Âá∫ÂÜÖÂ±ÇÂæ™ÁéØ
                    except Exception as e:
                        time.sleep(0.3)
                        print(e)
                    # print("Queuing...")
                    print(json.loads(ans)["msg"])
                break  # Ë∑≥Âá∫Â§ñÂ±ÇÂæ™ÁéØ


def time_update():
    """
    ÊØèÂ§©Êê∂Â∫ßÂáΩÊï∏ÈñãÂßãÂü∑Ë°åÁöÑÊôÇÂÄôÔºåÊõ¥Êñ∞Áï∂ÂâçÊôÇÈñìÔºàÊê∂Â∫ßÈñãÊîæÊôÇÈñìÔºâ
    :return:
    """
    # struct_openTime = "****-**-** 21:00:00"
    now = time.gmtime()
    return now.tm_year.__str__() + '-' \
           + now.tm_mon.__str__() + '-' \
           + now.tm_mday.__str__() + ' ' \
           + '21:00:00'


# ÂºÄÂßãÊó∂Èó¥
def preserve_tomorrow(session, usr: dict):
    # Êõ¥Êñ∞cookie
    cookie = usr['cookie']
    # websocketÁöÑËØ∑Ê±ÇÂ§¥ÁöÑÂΩ¢Âºè => dict
    queue_header_for_websockets['Cookie'] = cookie
    # ws4pyÁöÑËØ∑Ê±ÇÂ§¥ÁöÑÂΩ¢Âºè => tuples list
    # queue_header.append(('Cookie', cookie))
    # httpËØ∑Ê±ÇÁöÑËØ∑Ê±ÇÂ§¥
    pre_header['Cookie'] = cookie

    # Êõ¥Êñ∞‰∏∫ÂΩìÊó•Êä¢Â∫ßÊó∂Èó¥,open_time -> Êó∂Èó¥Êà≥
    open_time = time.mktime(time.strptime(time_update(), "%Y-%m-%d %H:%M:%S"))
    # Êó∂Èó¥Êà≥ËΩ¨Êç¢Êàêlocaltime,
    # ÂΩ¢Â¶ÇÔºötime.struct_time(tm_year=2023, tm_mon=9, tm_mday=25, tm_hour=12, tm_min=22, tm_sec=18,tm_wday=0, tm_yday=268, tm_isdst=0)
    # ËΩ¨Êç¢ÊàêÊñ∞ÁöÑÊó∂Èó¥Ê†ºÂºè(2016-05-05 20:28:54)
    print('üôèÊòéÊó•È¢ÑÁ∫¶ÂàùÂßãÂåñÂÆåÊàêÔºÅ')
    print('ÂΩìÂâçÊó∂Èó¥Ôºö', time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(time.time())), end=', ')
    print('ËøòÊúâ%fÁßíÂºÄÂßã' % (open_time - time.time()))
    # # ÂÖàÂª∫Á´ã‰∏Ä‰∏™socket
    # ws = CG_Client(
    #     url="wss://wechat.v2.traceint.com/ws?ns=prereserve/queue",
    #     headers=queue_header
    # )
    while True:
        if time.time() >= open_time:
            # print(time.time(), "‚è∞Êó∂Èó¥Âà∞ÔºåÂáÜÂ§áÂºÄÂßãÊä¢Â∫ß!")
            # start_time = time.time()
            """ws4py"""
            # # ÊéíÈòüÔºÅÁõ¥Êé•ÁúÅÂéªÂáΩÊï∞Ë∞ÉÁî®ÔºÅ
            # # queue_pass(ws)
            # ws.connect()
            # ws.run_forever()
            """websockets"""
            asyncio.run(queue_pass_websockets(open_time))
            # print(time.time(), 'üö•queue ==> ok!')
            try:
                for seat in the_seat_chosen:
                    # ÈáçË¶ÅÔºÅÂ¶ÇÊûú‰∏çÊòØÊîæÂú®Â∏∏Áî®Â∫ß‰ΩçÔºåÈúÄË¶ÅÂÖàËØ∑Ê±ÇÂØπÂ∫îÁöÑÈòÖËßàÂÆ§ÁöÑÊâÄÊúâÂ∫ß‰ΩçÔºålibLayoutÔºÅÔºÅ
                    session.post(
                        url=url,
                        headers=pre_header,
                        json=data_lib_chosen,  # libLayout
                        verify=False
                    )
                    # Êä¢Â∫ßÁöÑpostËØ∑Ê±ÇÔºåcore code
                    params_confirm_seat['variables']['key'] = seat + '.'
                    # print(params_confirm_seat)
                    text_save = session.post(
                        url=url,
                        headers=pre_header,
                        json=params_confirm_seat,  # save
                        verify=False
                    ).text
                    # print('‚è∞time when start queue:            ', start_time)
                    # print('‚è∞time consumption in queue:        ', queue_time - start_time)
                    print('üöísave  ==> ok!')
                    # print('‚è∞time consumption to preserve seat:', time.time() - queue_time)
                    # print(res.text)
                    text_res = session.post(
                        url=url,
                        headers=pre_header,
                        json=params_confirm_seat_info,  # prereserve
                        verify=False
                    ).text
                    print(time.ctime(), 'pre reserve:', str(text_res).encode('utf-8').decode('unicode_escape'))
                    print(time.ctime(), 'save       :', str(text_save).encode('utf-8').decode('unicode_escape'))

                    # if str(text_save).count("true") and text_res.count('user_mobile'):
                    if text_res.count('user_mobile'):
                        # Êä¢Â∫ßÊàêÂäüÂ∞±ËøîÂõû
                        print("üòçÊÅ≠Âñú‰Ω†ÔºÅÊòéÊó•È¢ÑÁ∫¶ÊàêÂäüÔºÅËÆ∞ÂæóÊó©Ëµ∑")
                        # queue_header.pop()
                        try:
                            my_email.goLib_email_info('success', json.loads(text_res))
                        except Exception as e:
                            print(e)
                            print('Ëé∑ÂèñÊØèÊó•ËØóËØçÂ§±Ë¥•„ÄÇ„ÄÇ„ÄÇ')
                        return True
                    else:
                        # ws = CG_Client(
                        #     url="wss://wechat.v2.traceint.com/ws?ns=prereserve/queue",
                        #     headers=queue_header
                        # )
                        # ËøûÁª≠‰∏§Ê¨°Êä¢Â∫ß‰πãÈó¥Èó¥ÈöîËá≥Â∞ë1s„ÄÇ„ÄÇ„ÄÇ„ÄÇ
                        time.sleep(1)
            except Exception as e:
                time.sleep(0.3)
                print(e)
            break
    # Êä¢Â∫ßÂ§±Ë¥•ÁöÑÈÄöÁü•
    # queue_header.pop()
    my_email.goLib_email_info('fail')
    return False


def keep_pre_reserve(session, usr):
    # ÈáçÂ§ç3Ê¨°ÔºÅ
    for i in range(0, 1):
        if preserve_tomorrow(session=session, usr=usr):
            break
    print(time_update().split(' ')[0] + "ÁöÑÊä¢Â∫ßÁªìÊùüÔºÅ")


# @catch_exceptions(cancel_on_failure=False)
def run_thread(param_dict):
    """
    scheduleÊØè‰∏ÄÊ¨°ÈáçÊñ∞ÈÅãË°åÁöÑÊôÇÂÄôÔºåÊúÉ‰øùÁïô‰∏ä‰∏ÄÊ¨°ÁöÑÊõ¥ÊîπÔºåÂåÖÊã¨scheduleÊâÄÂü∑Ë°åÁöÑÂáΩÊï∏ÁöÑÂΩ¢ÂèÉÁöÑËÆäÂåñÔºåÈÉΩÊúÉ‰∏ÄÁõ¥‰øùÁïô‚Ä¶‚Ä¶
    python‰∏çÂÆöÂèÉÊï∏ reference:https://blog.csdn.net/cadi2011/article/details/84871401
    """
    Thread(
        target=param_dict['func'],
        # ËøáÊª§ÊéâÂéüÂèÇÊï∞Â≠óÂÖ∏‰∏≠ÁöÑÈîÆfunc
        kwargs=dict(filter(lambda x: x[0] != 'func', param_dict.items()))
    ).start()


if __name__ == '__main__':
    initialization()
    # session ÂØπË±° =„Äã ‰øùÊ¥ª
    session = requests.session()
    print('üå†ÊàëÂéªÂõæ‰π¶È¶ÜÁ®ãÂ∫èÔºåÂêØÂä®ÔºÅüå† ', time.ctime())
    # ÂÖàËøõË°å‰∏ÄÊ¨°sessionÂàùÂßãÂåñËÆæÁΩÆÔºå
    keep_session_newest(session=session, usr_list=usr_list)

    # ÊØè3~5ÂàÜÈíüÂà∑Êñ∞cookie, ‰øùÊ¥ªsession
    schedule.every(4 * 60 + random.randint(-60, 60)).seconds.do(run_thread, param_dict={
        'func': keep_session_newest,
        'session': session,
        'usr_list': usr_list
    })
    # ÊØèÂ§©21Ôºö59ÂáÜÊó∂ÈÄÄÂ∫ß
    schedule.every().day.at("21:59:30").do(run_thread, param_dict={
        'func': withdraw_seat,
        'session': session,
        # ÊöÇÊó∂---Âè™ÁªôËá™Â∑±Ëá™Âä®ÈÄÄÂ∫ß
        'usr': usr_list[0]
    })
    # Á∫øÁ®ãËøõË°åÊä¢Â∫ßÔºÅ
    schedule.every().day.at("20:59:55").do(run_thread, param_dict={
        'func': preserve_tomorrow,
        'session': session,
        # ÊöÇÊó∂---Âè™ÁªôËá™Â∑±Ëá™Âä®Êä¢Â∫ß
        'usr': usr_list[0]
    })
    # schedule.every().day.at("20:59:00").do(run_thread, {
    #     'func': preserve_tomorrow,
    #     'session': session,
    #     'file_name': 'cookie_me.txt'
    # })

    while True:
        schedule.run_pending()
        time.sleep(1)


